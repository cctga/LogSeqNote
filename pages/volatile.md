- 实现原理
	- 使用 CPU 的内存屏障指令来防止 volatile 的重排序，以及保证读写的内存可见性
	- 由于不同的CPU架构的缓存体系不一样，重排序的策略不一样，所提供的[[内存屏障]]指令也就有差异。
	- 实现volatile关键字的语义的一种参考做法：
		-
		  1. 在volatile写操作的前面插入一个StoreStore屏障。保证volatile写操作不会和之前的写操作重排序。
		-
		  2. 在volatile写操作的后面插入一个StoreLoad屏障。保证volatile写操作不会和之后的读操作重排序。
		-
		  3. 在volatile读操作的后面插入一个LoadLoad屏障+LoadStore屏障。保证volatile读操作不会和之后的读操作、写操作重排序。
	- 具体到x86平台上，其实不会有LoadLoad、LoadStore和StoreStore重排序，只有StoreLoad一种重排序（内存屏障），也就是只需要在volatile写操作后面加上StoreLoad屏障。
	-
	- 其他的CPU架构做法不一
- 提供两种特性
	- 内存可见性：
		- 每次使用之前都要先刷新
		- volatile 变量对所有线程是立即可见的，
		- 对volatile变量所有的写操作都能立刻反映到其他线程之中。
		- 换句话 说，volatile变量在各个线程中是一致的
	- 拒绝重排序
		- Java 对于普通代码只能保证线程内是串行化的，在这个前提下，会使用重排序来提高执行效率
		- 比如很容易导致 A 线程读取配置，读取完成后置标志位为 true，然后 B 线程开始使用这个配置，但是重排序很可能将标志位的赋值提前，导致 B 线程使用出错
- > 只保证可见性，不保证原子性，会有并发问题